package com.nyx.shell.util;

import com.nyx.shell.ShellLexer;
import org.antlr.v4.runtime.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A utility class that uses ANTLR to tokenize shell input.
 *
 * <p>This class leverages ANTLR's lexer capabilities to split shell input into tokens while handling:
 * <ul>
 *   <li>Single quotes: Text between single quotes is taken literally.</li>
 *   <li>Double quotes: Text between double quotes supports escape sequences for \, $, " and newline.</li>
 *   <li>Unquoted text: Words that are not quoted.</li>
 * </ul>
 * Additionally, it concatenates adjacent tokens if no whitespace separates them (e.g. "world""test" becomes "worldtest").
 * For more information on ANTLR, visit the
 * <a href="https://www.antlr.org/">ANTLR Official Website</a>.
 * For details on shell quoting, see
 * <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash Quoting</a>.
 * </p>
 */
public class AntlrTokenizer {

    /**
     * Tokenizes the given input string using the ANTLR-generated ShellLexer.
     *
     * <p>This method creates a {@link CharStream} from the input, instantiates
     * a {@link ShellLexer} generated from the Shell.g4 grammar, and processes the tokens.
     * It removes surrounding quotes from quoted tokens, unescapes double-quoted tokens,
     * and then combines adjacent tokens (with no intervening whitespace) into a single token.
     * </p>
     *
     * @param input the raw input string from the user.
     * @return an array of tokens extracted from the input.
     */
    public static String[] tokenize(String input) {
        // Create a CharStream from the raw input.
        CharStream charStream = CharStreams.fromString(input);

        // Create a lexer instance using the generated ShellLexer.
        ShellLexer lexer = new ShellLexer(charStream);

        // Use CommonTokenStream to gather all tokens produced by the lexer.
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        tokens.fill();  // Load all tokens

        // Intermediate data structure to hold processed tokens along with their position info.
        List<TokenData> tokenDataList = new ArrayList<>();

        // Process each token generated by ANTLR.
        for (Token token : tokens.getTokens()) {
            // Skip whitespace tokens and the EOF token.
            if (token.getType() == ShellLexer.WS || token.getType() == Token.EOF) {
                continue;
            }
            String text = token.getText();
            int type = token.getType();

            // Process single-quoted strings: remove the surrounding quotes.
            if (type == ShellLexer.SQ_STRING) {
                // Remove the first and last character (the single quotes).
                text = text.substring(1, text.length() - 1);
            }
            // Process double-quoted strings: remove surrounding quotes and unescape sequences.
            else if (type == ShellLexer.DQ_STRING) {
                // Remove the surrounding double quotes.
                text = text.substring(1, text.length() - 1);
                // Unescape escape sequences (e.g., \" becomes ").
                text = unescapeDoubleQuoted(text);
            }

            // Store token text along with its original start and stop indices.
            tokenDataList.add(new TokenData(text, token.getStartIndex(), token.getStopIndex()));
        }

        // Combine adjacent tokens (those with no gap between them).
        List<String> combinedTokens = combineAdjacentTokens(tokenDataList);
        return combinedTokens.toArray(new String[0]);
    }

    /**
     * Unescapes escape sequences found in double-quoted tokens.
     *
     * <p>This method replaces escape sequences for double quotes, backslashes, and dollar signs.
     * For example, it converts {@code \"} to {@code "}, {@code \\} to {@code \}, and {@code \$} to {@code $}.
     * For more details on shell escaping, see:
     * <a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html">Bash Quoting</a>.
     * </p>
     *
     * @param text the text within double quotes.
     * @return the text with escape sequences processed.
     */
    private static String unescapeDoubleQuoted(String text) {
        // Replace occurrences of \" \\ or \$ with their literal counterparts.
        return text.replaceAll("\\\\([\"\\\\$])", "$1");
    }

    /**
     * Combines adjacent tokens from the list if they are contiguous in the input.
     *
     * <p>Two tokens are considered adjacent if the start index of the current token is exactly
     * one more than the stop index of the previous token. This is typical when two quoted strings
     * are placed next to each other without intervening whitespace.</p>
     *
     * @param tokenDataList the list of TokenData to combine.
     * @return a list of combined token strings.
     */
    private static List<String> combineAdjacentTokens(List<TokenData> tokenDataList) {
        List<String> result = new ArrayList<>();
        if (tokenDataList.isEmpty()) {
            return result;
        }

        // Start with the first token.
        TokenData current = tokenDataList.get(0);
        StringBuilder combined = new StringBuilder(current.text);
        int currentStop = current.stop;

        for (int i = 1; i < tokenDataList.size(); i++) {
            TokenData next = tokenDataList.get(i);
            // If next token starts immediately after the current token ends, they are adjacent.
            if (next.start == currentStop + 1) {
                combined.append(next.text);
                currentStop = next.stop;
            } else {
                // Not adjacent: add the current combined token to the result and start a new one.
                result.add(combined.toString());
                combined = new StringBuilder(next.text);
                currentStop = next.stop;
            }
        }
        // Add the final token.
        result.add(combined.toString());
        return result;
    }

    /**
     * A helper class to store token text along with its position in the input.
     */
    private static class TokenData {
        final String text;
        final int start;
        final int stop;

        TokenData(String text, int start, int stop) {
            this.text = text;
            this.start = start;
            this.stop = stop;
        }
    }
}
